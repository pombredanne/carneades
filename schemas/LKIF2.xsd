<?xml version="1.0" encoding="UTF-8"?>
<!--
  Carneades Argumentation Library and Tools.
  Copyright (C) 2008 Thomas F. Gordon, Fraunhofer FOKUS, Berlin
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License version 3 (LGPL-3)
  as published by the Free Software Foundation.
  
  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for details.
  
  You should have received a copy of the GNU Lesser General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
  <xs:element name="lkif">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="sources"/>
        <xs:element minOccurs="0" ref="theory"/>
        <xs:element minOccurs="0" ref="argument-graphs"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="sources">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="source"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="source">
    <xs:complexType>
      <xs:attribute name="element" use="required" type="xs:anyURI"/>
      <xs:attribute name="uri" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <!--
    RDF, OWL and LKIF files can be imported.  See below. 
    The rules are inference rules. The resulting theory is 
    the transitive closure of the axioms deduced using the rules.
  -->
  <xs:element name="theory">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="imports"/>
        <xs:element minOccurs="0" ref="axioms"/>
        <xs:element minOccurs="0" ref="rules"/>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="xs:ID"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="imports">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="import"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="axioms">
    <xs:complexType>
      <xs:group maxOccurs="unbounded" ref="Wff"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="rules">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="rule"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <!--
    Import: the uri can refer to an RDF file, including OWL files in RDF format, 
    an LKIF theory, an LKIF argument graph, or an entire LKIF file, in which case both the 
    theory and the argument graph in the file are imported. 
    When importing OWL files, not only the axioms of the ontology  
    are imported but also any assertions about instances, the ABox. 
  -->
  <xs:element name="import">
    <xs:complexType>
      <xs:attribute name="uri" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="argument-graphs">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="argument-graph"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="rule">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="head"/>
        <xs:element minOccurs="0" ref="body"/>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="xs:ID"/>
      <xs:attribute name="strict" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="head">
    <xs:complexType>
      <xs:group maxOccurs="unbounded" ref="Wff"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="body">
    <xs:complexType>
      <xs:group maxOccurs="unbounded" ref="Wff"/>
    </xs:complexType>
  </xs:element>
  <!--
    Atomic formulas. Propositional logic letters are represented by 
    omitting the (optional) predicate attribute.  The "s" tag
    is used for backwards compatibility and because it is probably
    more intuitive and mnemonic for most users.
    An assumable atom is assumed when an argument having this atom
    as a premise is put forward into an argument graph, unless there is already
    an issue for this atom (i.e. an atom with the same id), in which case
    the value of the assumption attribute of the issue for this atom is 
  -->
  <xs:element name="s">
    <xs:complexType mixed="true">
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="Term"/>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="pred">
        <xs:simpleType>
          <xs:union memberTypes="xs:anyURI xs:Name"/>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="assumable" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <!--
    Wffs are well-formed formulas of predicate logic, extended with exceptions and assumptions
    Free variables are schema variables, i.e. inference rule variables; 
    bound variables, using Exists or All, are first-order logic variables.
  -->
  <xs:group name="Wff">
    <xs:choice>
      <xs:element ref="s"/>
      <xs:element ref="or"/>
      <xs:element ref="and"/>
      <xs:element ref="not"/>
      <xs:element ref="if"/>
      <xs:element ref="iff"/>
      <xs:element ref="all"/>
      <xs:element ref="exists"/>
    </xs:choice>
  </xs:group>
  <xs:element name="or">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="Wff"/>
        <xs:group maxOccurs="unbounded" ref="Wff"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="assumable" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="and">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="Wff"/>
        <xs:group maxOccurs="unbounded" ref="Wff"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="assumable" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="not">
    <xs:complexType>
      <xs:group ref="Wff"/>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="exception" type="xs:boolean"/>
      <xs:attribute name="assumable" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="if">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="Wff"/>
        <xs:group ref="Wff"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="assumable" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="iff">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="Wff"/>
        <xs:group ref="Wff"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="assumable" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="all">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="v"/>
        <xs:group ref="Wff"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="assumable" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="exists">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="v"/>
        <xs:group ref="Wff"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="assumable" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <!-- Terms include statements, to support meta-level statements -->
  <xs:group name="Term">
    <xs:choice>
      <xs:element ref="v"/>
      <xs:element ref="i"/>
      <xs:element ref="c"/>
      <xs:element ref="expr"/>
      <xs:element ref="s"/>
    </xs:choice>
  </xs:group>
  <xs:element name="v" type="xs:Name"/>
  <xs:element name="i">
    <xs:complexType mixed="true">
      <xs:attribute name="value" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="c">
    <xs:simpleType>
      <xs:union memberTypes="xs:Name xs:anyURI xs:string xs:boolean xs:integer xs:float"/>
    </xs:simpleType>
  </xs:element>
  <!--
    The functors and constants of expressions are represented by
    URIs. Thus libraries of functions and operators can be
    declared in OWL ontologies.  Standard LKIF functions and operators
    could be part of the ontology of basic legal concepts.
  -->
  <xs:element name="expr">
    <xs:complexType>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="Term"/>
      <xs:attribute name="functor" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <!--
    In addition to a set of arguments, argument graphs can now include the status
    of issues, applicable proof standards and relative argument strengths.
  -->
  <xs:element name="argument-graph">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="issues"/>
        <xs:element ref="statements"/>
        <xs:element ref="arguments"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="main-issue" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="statements">
    <xs:complexType>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="Wff"/>
    </xs:complexType>
  </xs:element>
  <!--
    Issues labeled accepted and rejected are (assumed) to be true or false, respectively.  
    The previous status of statements can be reconstructed as follows: 
    	stated: value=unknown & assumption=true 
      questioned: value=unknown & assumption=false
      accepted: value=true & assumption=false
      rejected: value=false & assumption=false
    The new model allows us in 
    addition to assume the value to be false (value=false & assumption=true) or true
    (value=true & assumption=true).  Assumptions are now made globablly, in the
    scope of an argument graph, rather than on a premise by premise basis.
  -->
  <xs:element name="issues">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="issue"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="issue">
    <xs:complexType>
      <xs:attribute name="statement" use="required" type="xs:anyURI"/>
      <xs:attribute name="value" use="required">
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="unknown"/>
            <xs:enumeration value="true"/>
            <xs:enumeration value="false"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="assumption" type="xs:boolean"/>
      <xs:attribute name="standard">
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="SE"/>
            <xs:enumeration value="DV"/>
            <xs:enumeration value="BA"/>
            <xs:enumeration value="PE"/>
            <xs:enumeration value="BRD"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <!--
    Schemes and premise roles can be referenced using URIs.  They can be modeled
    as instances in an OWL ontology.
  -->
  <xs:element name="arguments">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="argument"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="argument">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="conclusion"/>
        <xs:element ref="premises"/>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="xs:ID"/>
      <xs:attribute name="direction">
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="pro"/>
            <xs:enumeration value="con"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="scheme">
        <xs:simpleType>
          <xs:union memberTypes="xs:anyURI xs:string"/>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="weight" type="xs:float"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="premises">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="premise"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="premise">
    <xs:complexType>
      <xs:attribute name="polarity">
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="positive"/>
            <xs:enumeration value="negative"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="exception" type="xs:boolean"/>
      <xs:attribute name="role">
        <xs:simpleType>
          <xs:union memberTypes="xs:anyURI xs:string"/>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="statement" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="conclusion">
    <xs:complexType>
      <xs:attribute name="statement" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
</xs:schema>
