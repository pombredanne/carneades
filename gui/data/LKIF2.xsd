<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
  <xs:element name="lkif">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="sources"/>
        <xs:element minOccurs="0" ref="rules"/>
        <xs:element minOccurs="0" ref="argument-graph"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="sources">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="source"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="source">
    <xs:complexType>
      <xs:attribute name="element" use="required" type="xs:anyURI"/>
      <xs:attribute name="uri" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <!-- The facts of a theory are axioms. The rules are inference rules. -->
  <xs:element name="rules">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="import"/>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="rule"/>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="xs:ID"/>
    </xs:complexType>
  </xs:element>
  <!--
    Import: the uri should refer to either an OWL ontology or an LKIF theory
    Facts can also be imported from an OWL file, i.e. the A-Box.
  -->
  <xs:element name="import">
    <xs:complexType>
      <xs:attribute name="uri" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="argument-graphs">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="argument-graph"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="rule">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="head"/>
        <xs:element minOccurs="0" ref="body"/>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="xs:ID"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="head">
    <xs:complexType>
      <xs:sequence>
        <xs:element maxOccurs="unbounded" ref="fact"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="body">
    <xs:complexType>
      <xs:group ref="Wff"/>
    </xs:complexType>
  </xs:element>
  <!-- Facts are literals, i.e. positive or negative atomic formulas -->
  <xs:element name="fact">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="s"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="value" type="xs:boolean"/>
    </xs:complexType>
  </xs:element>
  <!--
    Statements are atomic formulas.  Statements is propositional 
    logic are represented by omitting the (optional) predicate attribute.
  -->
  <xs:element name="s">
    <xs:complexType mixed="true">
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="Term"/>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="pred">
        <xs:simpleType>
          <xs:union memberTypes="xs:anyURI xs:Name"/>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <!--
    Wffs are well-formed formulas of predicate logic, extended with exceptions and assumptions
    As in Horn claus logic, variables are implicitly universally quantified,
    if they also appear in the head of the rule, otherwise they are implicitly 
    existentially quantified.
  -->
  <xs:group name="Wff">
    <xs:choice>
      <xs:element ref="s"/>
      <xs:element ref="unless"/>
      <xs:element ref="assuming"/>
      <xs:element ref="or"/>
      <xs:element ref="and"/>
      <xs:element ref="not"/>
      <xs:element ref="if"/>
      <xs:element ref="iff"/>
    </xs:choice>
  </xs:group>
  <xs:element name="unless">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="fact"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="assuming">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="fact"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="or">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="Wff"/>
        <xs:group maxOccurs="unbounded" ref="Wff"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="and">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="Wff"/>
        <xs:group maxOccurs="unbounded" ref="Wff"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="not">
    <xs:complexType>
      <xs:group ref="Wff"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="if">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="Wff"/>
        <xs:group ref="Wff"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="iff">
    <xs:complexType>
      <xs:sequence>
        <xs:group ref="Wff"/>
        <xs:group ref="Wff"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <!-- Terms include statements, to support meta-level statements -->
  <xs:group name="Term">
    <xs:choice>
      <xs:element ref="v"/>
      <xs:element ref="i"/>
      <xs:element ref="c"/>
      <xs:element ref="expr"/>
      <xs:element ref="s"/>
    </xs:choice>
  </xs:group>
  <xs:element name="v" type="xs:Name"/>
  <xs:element name="i">
    <xs:complexType mixed="true">
      <xs:attribute name="value" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="c">
    <xs:simpleType>
      <xs:union memberTypes="xs:Name xs:anyURI xs:string xs:boolean xs:integer xs:float"/>
    </xs:simpleType>
  </xs:element>
  <!--
    The functors and constants of expressions are represented by
    URIs. Thus libraries of functions and operators can be
    declared in OWL ontologies.  Standard LKIF functions and operators
    could be part of the ontology of basic legal concepts.
  -->
  <xs:element name="expr">
    <xs:complexType>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="Term"/>
      <xs:attribute name="functor" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <!--
    In addition to a set of arguments, argument graphs can now include the status
    of issues, applicable proof standards and relative argument strengths.
  -->
  <xs:element name="argument-graph">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" ref="issue"/>
        <xs:element minOccurs="0" ref="strengths"/>
        <xs:element ref="statements"/>
        <xs:element ref="arguments"/>
      </xs:sequence>
      <xs:attribute name="id" type="xs:ID"/>
      <xs:attribute name="main-issue" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="statements">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="s"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <!--
    Issues labeled accepted and rejected are (assumed) to be true or false,
    respectively.  
  -->
  <xs:element name="issue">
    <xs:complexType>
      <xs:attribute name="statement" use="required" type="xs:anyURI"/>
      <xs:attribute name="status">
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="stated"/>
            <xs:enumeration value="questioned"/>
            <xs:enumeration value="accepted"/>
            <xs:enumeration value="rejected"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="standard">
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="DV"/>
            <xs:enumeration value="SE"/>
            <xs:enumeration value="BA"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>
  <xs:element name="strengths">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="stronger"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="stronger">
    <xs:complexType>
      <xs:attribute name="arg1" use="required" type="xs:IDREF"/>
      <xs:attribute name="arg2" use="required" type="xs:IDREF"/>
    </xs:complexType>
  </xs:element>
  <!--
    Schemes and premise roles are referenced using URIs.  They can be modeled
    as instances in an OWL ontology.
  -->
  <xs:element name="arguments">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="argument"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="argument">
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="conclusion"/>
        <xs:element ref="premises"/>
      </xs:sequence>
      <xs:attribute name="id" use="required" type="xs:ID"/>
      <xs:attribute name="direction">
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="pro"/>
            <xs:enumeration value="con"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="scheme" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="premises">
    <xs:complexType>
      <xs:sequence>
        <xs:element minOccurs="0" maxOccurs="unbounded" ref="premise"/>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:element name="premise">
    <xs:complexType>
      <xs:attribute name="polarity">
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="positive"/>
            <xs:enumeration value="negative"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="type">
        <xs:simpleType>
          <xs:restriction base="xs:token">
            <xs:enumeration value="ordinary"/>
            <xs:enumeration value="exception"/>
            <xs:enumeration value="assumption"/>
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="role" type="xs:anyURI"/>
      <xs:attribute name="statement" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
  <xs:element name="conclusion">
    <xs:complexType>
      <xs:attribute name="statement" use="required" type="xs:anyURI"/>
    </xs:complexType>
  </xs:element>
</xs:schema>
